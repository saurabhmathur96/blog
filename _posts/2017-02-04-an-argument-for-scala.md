---
layout: post
title:  "An argument for Scala"
date:   2017-02-04
categories: scala
---

I gave a presentation on Scala as an assignment for my Open Source Programming class. While researching for 
the presentation, I came across many interesting talks and articles about the language and its philosophy. 
What follows is an attempt to condense that information as set of reasons to use Scala for a project.

Since it is difficult to include the entire set of features of a language in a 15 minute presentation, and
hello world and fizz buzz would not do justice to the language, I decided to speak on the why of Scala
instead of the what and how. 

Find the slides [here](https://github.com/saurabhmathur96/presentations/blob/master/OSP/introduction-to-scala.pdf).

## A better Java

Consider this piece of java code. It defines an abstract data type, *ComplexNumber* that has constant 
real and imaginary parts. 

```Java
public class ComplexNumber  {
 
    private final double real;
    private final double imaginary;
    
    public ComplexNumber(double r, double i) {
        real = r;
        imaginary = i;
    }
    
    public double getRealPart() {
        return real;
    }
    
    public double getImaginaryPart() {
        return imaginary;
    }   
    
}
```

What I intend to demonstrate is that I've written an entire page of code and it does not accomplish anything yet.
Sure, all this code can be generated by an IDE. But it still adds to the code that I need to maintain.

Java prides itself over being Object Oriented - yet it has primitive types like *double* and *int* that are
not Classes. Using a wrapper class like *Double* or *Integer* costs additional memory. This is not to discredit
java. Java has a lot going for it - a great standard library, cross platform code, lots of external 
3rd party libraries. However, all the great things about Java are actually about the Java Platform and not
about the language. This is one of the primary reasons Scala was developed - as a better Java.

The exact same code written in Scala.

```Scala
class ComplexNumber (val real:Double, val imaginary:Double)
```

Let's break it down one by one.
- *val* declares a constant member similar to *final* in java.
- *real:Double* declares that the member real is of type *Double*.
- This statement also generates getter methods (Since the members are constants, setters are unnessary)


```Scala
val origin = ComplexNumber(0, 0)
println(origin.real)
```


## Java Interop

Using Java and using Scala are not two disjoint things. Scala code too, compiles to the same bytecode as Java.
So code written in Scala can be used in java without ever needing to know it was written in scala. 
On the flip side, all Java libraries can be used in Scala. 


## Functional

Scala provides you with a wide array of features. So you can go completely object oriented or write completely
functional code or use the best of both in the same language. Functional Programming support also makes it a 
better choice for writing concurrent code.

```Scala
val sumOfSquares = 1.until(10).map(math.pow(_, 2)).sum
```
Scala also provides a mixed Object oriented and Functional form of a *class* called *case class*.
It has all the features of a class but is immutable and has additional helper methods.

## XML Processing

Scala has syntax for processing XML documents built in. For instance,

```Scala
val page = 
  <html>
    <head>
      <title>Hello XHTML world</title>
    </head>
    <body>
      <h1>Hello world</h1>
      <p><a href="scala-lang.org">Scala</a> talks XHTML</p>
    </body>
  </html>;

  val nodes = page \\ "p"
```
XPath syntax is provided by the language too.

## Conclusion

Scala promises to become what Java could not. While it has some amazing features, Scala has its share of 
problems too.

The concise syntax is a double edged sword - clean code comes with a steep learning rate. The Scala team 
introduces a lot of breaking changes with each version - so it could be hard to keep updating your codebase.
Being a young language, Scala does not have as large a community as the likes Java or C#. As a result,
your options when choosing an IDE are limited.

These problems are likely to be mitigated in the near future. 

In closing, I have come to realise that the answer to the question "When should I use Scala ?"
is - when you are developing for the future.